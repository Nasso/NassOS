local parentShell = shell

local bExit = false
local sDir = (parentShell and parentShell.dir and parentShell.dir()) or ""
local sPath = (parentShell and parentShell.path and parentShell.path()) or ".:/rom/programs"
local tAliases = (parentShell and parentShell.aliases and parentShell.aliases()) or {}
local tProgramStack = {}

local bClock = true

local saveDir= (parentShell and parentShell.getRunningProgram and parentShell.getRunningProgram()) or "/" 
saveDir=string.sub(saveDir,1,#saveDir-#fs.getName(saveDir))
if fs.isReadOnly(saveDir) then saveDir="/" end


local shell = {}
local tEnv = {
	["shell"] = shell
}

--[[ Colours  --]]
local promptColour, textColour, bgColour
if term.isColour() then
	promptColour = colours.yellow
	textColour = colours.white
	bgColour = colours.black
else
	promptColour = colours.white
	textColour = colours.white
	bgColour = colours.black
end

--[[ Standard Shell Functions --]]

local function run( _sCommand, ... )
	local sPath = shell.resolveProgram( _sCommand )
	if sPath ~= nil then
		tProgramStack[#tProgramStack + 1] = sPath
   		local result = os.run( tEnv, sPath, ... )
		tProgramStack[#tProgramStack] = nil
		return result
   	else
    	printError( "No such program" )
    	return false
    end
end

local function runLine( _sLine )
	local tWords = {}
	for match in string.gmatch( _sLine, "[^ \t]+" ) do
		table.insert( tWords, match )
	end
	local sCommand = tWords[1]
	if sCommand then
		return run( sCommand, unpack( tWords, 2 ) )
	end
	return false
end

--[[ Install shell API  --]]
function shell.run( ... )
	return runLine(table.concat( { ... }, " " ))
end

function shell.exit()
    bExit = true
end

function shell.dir()
	return sDir
end

function shell.setDir( _sDir )
	sDir = _sDir
end

function shell.path()
	return sPath
end

function shell.setPath( _sPath )
	sPath = _sPath
end

function shell.resolve( _sPath )
	local sStartChar = string.sub( _sPath, 1, 1 )
	if sStartChar == "/" or sStartChar == "\\" then
		return fs.combine( "", _sPath )
	else
		return fs.combine( sDir, _sPath )
	end
end

function shell.resolveProgram( _sCommand )
	--[[ Substitute aliases firsts  --]]
	if tAliases[ _sCommand ] ~= nil then
		_sCommand = tAliases[ _sCommand ]
	end

    --[[ If the path is a global path, use it directly  --]]
    local sStartChar = string.sub( _sCommand, 1, 1 )
    if sStartChar == "/" or sStartChar == "\\" then
    	local sPath = fs.combine( "", _sCommand )
    	if fs.exists( sPath ) and not fs.isDir( sPath ) then
			return sPath
    	end
		return nil
    end
	
	--[[  Otherwise, look on the path variable  --]]
    for sPath in string.gmatch(sPath, "[^:]+") do
    	sPath = fs.combine( shell.resolve( sPath ), _sCommand )
    	if fs.exists( sPath ) and not fs.isDir( sPath ) then
			return sPath
    	end
    end
	
	--[[ Not found  --]]
	return nil
end

function shell.programs( _bIncludeHidden )
	local tItems = {}
	
	--[[ Add programs from the path  --]]
    for sPath in string.gmatch(sPath, "[^:]+") do
    	sPath = shell.resolve( sPath )
		if fs.isDir( sPath ) then
			local tList = fs.list( sPath )
			for n,sFile in pairs( tList ) do
				if not fs.isDir( fs.combine( sPath, sFile ) ) and
				   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= ".") then
					tItems[ sFile ] = true
				end
			end
		end
    end	

	--[[ Sort and return  --]]
	local tItemList = {}
	for sItem, b in pairs( tItems ) do
		table.insert( tItemList, sItem )
	end
	table.sort( tItemList )
	return tItemList
end

function shell.getRunningProgram()
	if #tProgramStack > 0 then
		return tProgramStack[#tProgramStack]
	end
	return nil
end

function shell.setAlias( _sCommand, _sProgram )
	tAliases[ _sCommand ] = _sProgram
end

function shell.clearAlias( _sCommand )
	tAliases[ _sCommand ] = nil
end

function shell.aliases()
	--[[ Add aliases  --]]
	local tCopy = {}
	for sAlias, sCommand in pairs( tAliases ) do
		tCopy[sAlias] = sCommand
	end
	return tCopy
end


--[[ My Functions --]] --[[ My Functions --]] --[[ My Functions --]]

--[[ File Useage --]]
local function save(A,B) local file = fs.open(tostring(A),"w") file.write(B) file.close() end
local function saveT(A,B) save(A,textutils.serialize(B)) end
local function saveTH(A,B) save(A,string.gsub(textutils.serialize(B),"},","},\r\n")) end
local function get(A) local file = fs.open(tostring(A),"r") if not file then return false end local data = file.readAll() file.close() if data then return data end end
local function getT(A) local data = get(A) if data then data = textutils.unserialize(data) end if data then return data end end

-- pastebin code

local pastebin={}
pastebin={
api_user_key = false,
api_dev_key="6ee24782806f592dc9b3be30960fe117",
login=function(api_user_name,api_user_password)
	handle=http.post("http://pastebin.com/api/api_login.php","api_user_name="..textutils.urlEncode(api_user_name).."&api_user_password="..textutils.urlEncode(api_user_password).."&api_dev_key="..textutils.urlEncode(pastebin.api_dev_key))
	local out=handle.readAll()
	handle.close()
	return out
end,
listall=function()
	handle=http.post("http://pastebin.com/api/api_post.php","api_user_key="..textutils.urlEncode(pastebin.api_user_key).."&api_results_limit="..textutils.urlEncode(tostring(1000)).."&api_dev_key="..textutils.urlEncode(pastebin.api_dev_key).."&api_option=list")
	local out=handle.readAll()
	handle.close()
	return out
end,
user=function()
	handle=http.post("http://pastebin.com/api/api_post.php","api_user_key="..textutils.urlEncode(pastebin.api_user_key).."&api_dev_key="..textutils.urlEncode(pastebin.api_dev_key).."&api_option=userdetails")
	local out=handle.readAll()
	handle.close()
	return out
end,
tabulate=function(A)
    local out = {}
    for i, k in string.gmatch(A, "<(.-)>(.-)</%1>") do
        local temp = {}
        for j, l in string.gmatch(k, "<"..i.."_(.-)>(.-)</"..i.."_%1>") do
            temp[j] = l
        end
        table.insert(out,temp)
    end
    return out
end,
getone=function(code)
	handle=http.get("http://pastebin.com/raw.php?i="..code)
	if not handle then return nil end
	local out=handle.readAll()
	handle.close()
	return out
end
}

--[[ Read without any writes() - visually conceals leanght of password from wiever --]]
local function saferead()
	term.setCursorBlink( true )
    local sLine = ""
	local nPos = 0
	local w, h = term.getSize()
	local sx, sy = term.getCursorPos()		
	while true do
		local sEvent, param = os.pullEvent()
		if sEvent == "char" then
			sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )
			nPos = nPos + 1
		elseif sEvent == "key" then
		    if param == keys.enter then
				--[[ Enter --]]
				break
			elseif param == keys.backspace then
				--[[ Backspace --]]
				if nPos > 0 then
					sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )
					nPos = nPos - 1		
				end
			end
		end
	end
	term.setCursorBlink( false )
	term.setCursorPos( w + 1, sy )
	print()
	return sLine
end

local function pastelogin()
	if not http then print("Http Api is offline - this will not work. Sorry") return end 
	pcall( function()
		if not pastebin.api_user_key then
			write("Username: ") 
			local a=read()
			write("Password: ")
			--[[ Passowrd is not stored - is used and forgotten --]]
			local response=pastebin.login(a,saferead())
			if string.find(string.lower(response), "bad api request" , 1 , true) then print("Login Unsuccessful") pastebin.api_user_key = false
			else print("Login Successful") pastebin.api_user_key = response end
		else
			print("Already Logged in as "..pastebin.tabulate(pastebin.user())[1]["name"]..". Use plogout< to logout if you want to change users.")
		end
	end)
end

local function pastelogout()
	pastebin.api_user_key = false print("Logout Successful")
end

local function pastewho()
	if not http then print("Http Api is offline - this will not work. Sorry") return end 
	if not pastebin.api_user_key then print(" No user logged in - Please use plogin< to login") return end
	pcall( function()
		print("User logged in - displaying data:")
		local user=pastebin.tabulate(pastebin.user())[1]
		for i,k in pairs(user) do
		print(i," : ",k)
		end
	end)
end

local function pasteget(_Where)
	if not http then print("Http Api is offline - this will not work. Sorry") return end 
	if not pastebin.api_user_key then print(" No user logged in - Please use plogin< to login") return end
	
	pcall( function()
		local dir=fs.combine(saveDir,"Pastes")
		if not _Where and not fs.exists(dir) then fs.makeDir(dir) end
		
		print("Downloading Filelist")
		local pastes=pastebin.tabulate(pastebin.listall())
		
		for i=#pastes,1,-1 do --[[Removing private Pastes - no way to download them--]]
			if pastes[i].private==2 then table.remove(pastes,i) end
		end
		
		local offset=0
		local selected=1
		local All=false
		
		local function List()
			local x,y=term.getSize()
			term.clear()
			if #pastes > y-1 then offset=math.max(0,math.min(#pastes-(y-1),selected-math.floor((y-1)/2))) else offset=0 end
			for i=1,math.min(y-1,#pastes) do
				term.setCursorPos(1,i)
				if i+offset==selected then
				term.setTextColour(colours.black)
				term.setBackgroundColor(colours.white)
				else
				term.setTextColour(colours.white)
				term.setBackgroundColor(colours.black)
				end
				local temp=pastes[i+offset]
				term.write((temp.private=="1" and "." or "")..(temp.selected and "> " or "")..temp["title"]..(temp.selected and " <" or ""))
			end
			term.setTextColour(colours.white)
			term.setBackgroundColor(colours.black)
			term.setCursorPos(1,y)
			if _Where then
			term.write("Up/Down,D-Download")
			else
			term.write("Up/Down,Enter-Sel,D-Download,Tab-D-All")
			end
		end

		List()
		
		while true do
			event= {os.pullEvent()}
			if event[1]=="key" then
				if event[2]==keys.down then
					selected=math.min(selected+1,#pastes)
					List()
				elseif event[2]==keys.up then
					selected=math.max(selected-1,1)
					List()
				elseif event[2]==keys.d then
					if _Where then pastes[selected]["selected"]=true end
					print()
					print("Downloading Selected")	
					break
				elseif not _Where and (event[2]==keys.numPadEnter or event[2]==keys.enter)then
					pastes[selected]["selected"]=not pastes[selected]["selected"]
					List()
				elseif not _Where and  event[2]==keys.tab then
					print()
					print("Downloading All")
					All=true
					break
				end
			end --if event
		end
		
		term.setTextColour(colours.white)
		term.setBackgroundColor(colours.black)
		
		for _,k in pairs(pastes) do
			if k.selected or All then
				local name=string.gsub(k["title"]," ","_")
				print("Downloading "..name)
				local file =nil
				while true do
					file = pastebin.getone(k["key"])
					if file then break end
					print("Failed - Retrying in 5 sec")
					sleep(5)
					print("Downloading "..name)
				end
				if _Where then save(_Where,file)
				else save(fs.combine(dir,name),file) end
				print("Finished")
			end
		end
		
		print("Downloaded to ",_Where or dir )
	end)
end

local function pasteput()
	if not http then print("Http Api is offline - this will not work. Sorry") return end 
	--[[To be added at later date--]]
end

-- lua code

local LuatEnv = {}
setmetatable( LuatEnv, { __index = getfenv() } )

local function runlua( _sCommand )
	if not _sCommand then return false end


	local nForcePrint = 0
	local func, e = loadstring( _sCommand, "lua" )
	local func2, e2 = loadstring( "return ".._sCommand, "lua" )
	if not func then
		if func2 then
			func = func2
			e = nil
			nForcePrint = 1
		end
	else
		if func2 then
			func = func2
		end
	end
	
	if func then
        setfenv( func, LuatEnv )
        local tResults = { pcall( function() return func() end ) }
        if tResults[1] then
        	local n = 1
        	while (tResults[n + 1] ~= nil) or (n <= nForcePrint) do
        		print( tostring( tResults[n + 1] ) )
        		n = n + 1
        	end
        else
        	printError( tResults[2] )
        end
    else
    	printError( e )
    end
    
end

-- cat code

local function cat(_Tfiles)
	_,y=term.getSize()
	local out={}
	
	pcall( function()
		for i,k in ipairs(_Tfiles) do
			local path=shell.resolve(k)
			if not fs.exists(path) then print("File "..k.." don't exists") return end
			if fs.isDir(path) then print(k.." is a directory") return end
			local file = fs.open(path, "r")
			table.insert(out,file.readAll())
			file.close()
		end
		textutils.pagedPrint(table.concat(out))
	end)
end

-- find code

local function findfile(target,patt)
	if target=="" then print("No target specified") return end
	local matches={}
	target=string.lower(target)
	
	local function process(path)
		local T=fs.list(path)
		for _,k in ipairs(T) do
			local cpath=path.."/"..k
			if string.find(string.lower(k), target , 1 , not patt) then table.insert(matches,cpath) end
			if fs.isDir(cpath) then process(cpath) end
		end
	end
	
	local function list(_Tlist)
		local tFiles = {}
		local tVFiles = {}
		local tDirs = {}
		local tVDirs = {}
		for n, sItem in pairs(_Tlist) do
			if fs.isDir( sItem ) then
				table.insert( tDirs, sItem )
			else
				table.insert( tFiles, sItem )
			end
		end
		table.sort( tDirs ) table.sort( tVDirs ) table.sort( tFiles ) table.sort( tVFiles )
		if term.isColour() then
			textutils.pagedTabulate(colors.green , tDirs , colors.white, tFiles)
		else
			textutils.pagedTabulate(tDirs , tFiles)
		end
	end
	
	pcall( function()
		process("")
		list(matches)
	end)
end

-- read with tab-completition code

local function readtab( _sReplaceChar, _tHistory , _sPrefix)
	term.setCursorBlink( true )

    local sLine = _sPrefix or ""
	local nHistoryPos = nil
	local nPos = string.len(sLine)
    if _sReplaceChar then
		_sReplaceChar = string.sub( _sReplaceChar, 1, 1 )
	end
	
	local w, h = term.getSize()
	local sx, sy = term.getCursorPos()	
	local clocvis
	
	local function shellclock(_clear)
		if  bClock and not _clear and sx+#sLine <= w-7 then
			clocvis=true
			term.setCursorBlink( false )
			local state=textutils.formatTime(os.time(),true)
			while #state<5 do state=" "..state end
			local x=term.getCursorPos()
			term.setCursorPos( w-5, sy )
			term.setTextColour( promptColour )
			write(state)
			term.setTextColour( textColour )
			term.setCursorPos( x, sy )
			term.setCursorBlink( true )
		else
			if clocvis then
				local x=term.getCursorPos()
				term.setCursorBlink( false )
				term.setCursorPos( w-5, sy )
				write("     ")
				term.setCursorPos( x, sy )
				term.setCursorBlink( true )
				clocvis=false			
			end
		end		
	end
	
	local function redraw( _sCustomReplaceChar )
		local nScroll = 0
		if sx + nPos >= w then
			nScroll = (sx + nPos) - w
		end
		shellclock()
		term.setCursorPos( sx, sy )
		local sReplace = _sCustomReplaceChar or _sReplaceChar
		if sReplace then
			term.write( string.rep( sReplace, string.len(sLine) - nScroll ) )
		else
			term.write( string.sub( sLine, nScroll + 1 ) )
		end
		term.setCursorPos( sx + nPos - nScroll, sy )
	end

	local function list(_Tlist,_Spath,_Bhide)
		shellclock(true)
		local tFiles = {}
		local tVFiles = {}
		local tDirs = {}
		local tVDirs = {}
		for n, sItem in pairs(_Tlist) do
			if not (_Bhide and string.sub( sItem, 1, 1 )==".") then
				local sPath = fs.combine( _Spath, sItem )
				if fs.isDir( sPath ) then
					table.insert( tDirs, sItem )
				else
					table.insert( tFiles, sItem )
				end
			end
		end
		table.sort( tDirs ) table.sort( tVDirs ) table.sort( tFiles ) table.sort( tVFiles )
		print()
		if term.isColour() then
			pcall( function()
			textutils.pagedTabulate( colors.green , tDirs , colors.white, tFiles)
			end)
		else
			pcall( function()
			textutils.pagedTabulate( tDirs , tFiles)
			end)
		end
		term.setTextColour( promptColour )
		write( shell.dir() .. "> " )
		term.setTextColour( textColour )
		sx, sy = term.getCursorPos()
	end
	
	local function common(_String,_Min,_Cur)
		if not _Cur then return _String end
		local long=_Cur
		for i=math.min(#_String,#_Cur),_Min,-1 do
			local a,b=string.sub (_String,1,i),string.sub(_Cur,1,i)
			if a==b then return a end		
		end	
		return string.sub (_Cur,1,_Min)
	end
	
	local tick
	if bClock then tick=os.startTimer(1) end
	redraw()
	while true do
		local sEvent, param = os.pullEvent()
		if sEvent =="timer" and param==tick then shellclock() tick=os.startTimer(1)
		elseif sEvent == "char" then
			sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )
			nPos = nPos + 1
			redraw()
			
		elseif sEvent == "key" then
		    if param == keys.enter then
				--[[ Enter --]]
				shellclock(true)
				break
				
			elseif param == keys.left then
				--[[ Left --]]
				if nPos > 0 then
					redraw(" ")
					nPos = nPos - 1
					redraw()
				end
				
			elseif param == keys.right then
				--[[ Right --]]				
				if nPos < string.len(sLine) then
					redraw(" ")
					nPos = nPos + 1
					redraw()
				end
			
			elseif param == keys.up or param == keys.down then
                --[[ Up or down --]]
				if _tHistory then
					redraw(" ")
					if param == keys.up then
						--[[ Up --]]
						if nHistoryPos == nil then
							if #_tHistory > 0 then
								nHistoryPos = #_tHistory
							end
						elseif nHistoryPos > 1 then
							nHistoryPos = nHistoryPos - 1
						end
					else
						--[[ Down --]]
						if nHistoryPos == #_tHistory then
							nHistoryPos = nil
						elseif nHistoryPos ~= nil then
							nHistoryPos = nHistoryPos + 1
						end						
					end
					if nHistoryPos then
                    	sLine = _tHistory[nHistoryPos]
                    	nPos = string.len( sLine ) 
                    else
						sLine = ""
						nPos = 0
					end
					redraw()
                end
			elseif param == keys.backspace then
				--[[ Backspace --]]
				if nPos > 0 then
					redraw(" ")
					sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )
					nPos = nPos - 1					
					redraw()
				end
			elseif param == keys.home then
				--[[ Home --]]
				redraw(" ")
				nPos = 0
				redraw()		
			elseif param == keys.delete then
				if nPos < string.len(sLine) then
					redraw(" ")
					sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 )				
					redraw()
				end
			elseif param == keys["end"] then
				--[[ End --]]
				redraw(" ")
				nPos = string.len(sLine)
				redraw()
			elseif param == keys.tab and (string.sub( sLine, nPos+1 ,nPos+1)==" " or nPos==string.len(sLine)) then
				--[[ Tab  --]]
				local need=string.match(string.sub(sLine,1,nPos),"[ ]?([^ ]-)$")
				if need=="" or string.match(need,"[\\/]$") then

					--[[looking at root or /,\ at end mean folder --]]
					local path=shell.resolve(need or "")
					if fs.exists(path) and fs.isDir(path) then list(fs.list(path),path,true) end
					
				else
					--[[have part of name --]]					
					--[[get absolute path and target name --]]
					local path=""
					local targ=""
					if need=="." or string.match(need,"[\\/]%.$") then --[[lokking for hidden in folder --]]
						path=shell.resolve(need).."/"
						targ="."
					else --[[lokking for normal file --]]
						path=shell.resolve(need)
						targ=fs.getName(path)
					end
					
					--[[get path without name and see it iteven exists --]]
					path=string.sub(path,1,#path-#targ) or ""
					if fs.exists(path) and fs.isDir(path) then
						
						--[[find files in path matching part --]]
						--[[at same time look for longest common leading substing --]]
						local out={}
						local long=nil
						local lim=#targ
						 --[[Sanitizing magic for pattern needs ^$()%.[]*+-?--]]
						local pattern="^"..string.gsub(string.lower(targ),"[%^%$%(%)%%%.%[%]%*%+%-%?]",function(A) return "%"..A end)
						for i,k in pairs(fs.list(path)) do
							local tempS=string.lower(k)
							if string.match(tempS,pattern) then
								table.insert(out,k)
								long=common(tempS,lim,long)
							end
						end
						if #out==1 then
							if fs.isDir(fs.combine(path,out[1])) then out[1]=out[1].."/" end
							sLine=string.sub(sLine,1,nPos-#targ)..out[1]..string.sub( sLine, nPos + 1 )
							nPos = nPos-#targ+#out[1]
						elseif #out>1 then
							sLine=string.sub( sLine, 1, nPos-#targ )..long..string.sub( sLine, nPos + 1 )
							nPos = nPos-#targ+#long
							list(out,path)							
						end	
					end
				end
				redraw()
			end
		end
	end
	
	term.setCursorBlink( false )
	term.setCursorPos( w + 1, sy )
	print()
	
	return sLine
end

--[[ Back to standard shell with extended modyfications  --]]
	
term.setBackgroundColor( bgColour )
term.setTextColour( promptColour )
print( os.version(), " Extended v 2.1" )
term.setTextColour( textColour )

--[[ If this is the toplevel shell, run the startup programs  --]]
if parentShell == nil then
	--[[ Run the startup from the ROM first  --]]
	local sRomStartup = shell.resolveProgram( "/rom/startup" )
	if sRomStartup then
		shell.run( sRomStartup )
	end
	
	--[[ Then run the user created startup, from the disks or the root  --]]
	local sUserStartup = shell.resolveProgram( "/startup" )
	for n,sSide in pairs( peripheral.getNames() ) do
		if disk.isPresent( sSide ) and disk.hasData( sSide ) then
			local sDiskStartup = shell.resolveProgram( fs.combine(disk.getMountPath( sSide ), "startup") )
			if sDiskStartup then
				sUserStartup = sDiskStartup
				break
			end
		end
	end
	
	if sUserStartup then
		shell.run( sUserStartup )
	end
end

--[[ Run any programs passed in as arguments  --]]
local tArgs = { ... }
if #tArgs > 0 then
	shell.run( ... )
end

--[[ Read commands and execute them -- Most of modyfications happend here  --]]
local tCommandHistoryfile=fs.combine(saveDir,".shellhistory.log")
local tCommandHistory = {}
if fs.exists(tCommandHistoryfile) then tCommandHistory = getT(tCommandHistoryfile) or {} end
local nextprefix = ""
while not bExit do
	local a=term.getCursorPos()	--making sure it will not go out of screen
	if a>1 then print() end
	
	term.setBackgroundColor( bgColour )
	term.setTextColour( promptColour )
	write( shell.dir() .. "> " )
	term.setTextColour( textColour )
	
	local sLine = readtab( nil, tCommandHistory ,nextprefix)
	nextprefix = ""
	if sLine~="" then
	
		if sLine ~= tCommandHistory[#tCommandHistory] then
			table.insert( tCommandHistory, sLine )
			if tCommandHistory[101] then table.remove(tCommandHistory,1) end
			saveT(tCommandHistoryfile,tCommandHistory)
		end
		
		local tWords = {}
			for match in string.gmatch( sLine, "[^ \t]+" ) do
			table.insert( tWords, match )
		end
		local sCommand = table.remove(tWords,1)
		
		if sCommand == "lua<" then --[[ Lua Execution --]]
			runlua( string.sub( sLine, 6) )
			nextprefix = "lua< "
		elseif sCommand == "lua#" then --[[ Lua Clear --]]
			LuatEnv = {} setmetatable( LuatEnv, { __index = getfenv() } ) print("Shell Lua Enviroment Cleared")
		elseif sCommand == "cat<" then	--[[ Cat Execution --]]
			cat(tWords)	
		elseif sCommand == "clock<" then	--[[ Clock Toggle --]]
			bClock=not bClock print("Clock ",(bClock and "On")or"Off")
		elseif sCommand == "find<" then	--[[ Find Execution --]]
			findfile(string.sub( sLine, 7))
		elseif sCommand == "findpattern<" then	--[[ Find with pattern Execution --]]
			findfile(string.sub( sLine, 14),true)
		elseif sCommand == "plogin<" then	--[[ pastebin login --]]
			pastelogin()
		elseif sCommand == "plogout<" then	--[[ pastebin plogout --]]
			pastelogout()
		elseif sCommand == "pget<" then	--[[  pastebin get one file --]]
			local tar=string.sub( sLine, 7)
			pasteget(shell.resolve(tar))
		elseif sCommand == "plist<" then	--[[  pastebin get x files--]]
			pasteget()
		elseif sCommand == "pwho<" then	--[[ pastebin get user info --]]
			pastewho()
		elseif sCommand == "help<" or sCommand == "?<"  then	--[[ Help Execution --]]
			print("List of extra shell commands: lua<,lua#,cat<,clock<,find<,findpattern<,help<",(http and ",plogin<,plogout<,pget<,plist<" or ""))
		elseif sCommand then --[[ Standard Execution --]]
			run( sCommand, unpack( tWords ) )
		end
	end	
end

--[[ If this is the toplevel shell, run the shutdown program  --]]
if parentShell == nil then
	if shell.resolveProgram( "shutdown" ) then
		shell.run( "shutdown" )
	end
	os.shutdown() --[[ just in case  --]]
end

term.setTextColour( promptColour )
print("Extended Shell Terminated.")
print("Have a Nice Day!")
term.setTextColour( textColour )